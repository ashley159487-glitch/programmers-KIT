def solution(word):
    vowels = ['A', 'E', 'I', 'O', 'U']
    words = []
    def dfs(current) :
        if len(current) > 5 :
            return
        if current :
            words.append(current)
        for i in vowels :
            dfs(current + i)
    dfs('')
    return words.index(word) + 1
============================================
재귀를 써서 단어들을 빈 리스트에 순서대로 넣는다.
이 때 한 단어의 최대 길이는 5이므로 5가 넘는 단어는 리스트에 담지 않는다.
이렇게 A 부터 UUUUU까지 전부 리스트에 담고 word가 words리스트의 몇번째 인덱스에있는지
찾아서 리턴한다. 인덱스는 0부터 시작하므로 1을 더해줘 순서를 맞춰준다.
==============================================
이 방식의 논리 자체는 쉬워서 이해가 가는데 이걸 구현하는게 어렵다.
그냥 반복문을 쓰면 AEIOU가 저장되는데 어떻게 A, AA, AAA 이렇게 순서대로 들어가는지 이해가 안간다...
==============================================
2026/02/27
오늘 다시 이 문제를 풀면서 답답했던 것들이 많이 해소 되었다.
왜 A, AA, AAA 이렇게 리스트에 담길 수 있는지 알아보자면
for i in vowels :
    dfs(current + i)
여기서 i가 A일 때 다음 dfs를 부르면 현재의 for문은 A자리에 멈춰서서 자식 함수가 끝날 때까지 기다리기 때문이다.
그렇게 AAAAA까지 채워지면 그 다음부터는 자식함수 맨 위의 조건문에 걸리게되어 for문이 E로 넘어가게 되고 AAAAAE가 되는데
이것도 마찬가지로 조건문에 걸리게 되므로 for문은 AAAA에서 E를 붙이게 된다.
